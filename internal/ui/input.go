package ui

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
)

// FieldDependency defines a dependency relationship between input fields
type FieldDependency struct {
	SourceIndex int                             // Index of the source field
	TargetIndex int                             // Index of the target field
	UpdateFunc  func(sourceValue string) string // Function to compute target value from source
}

type InputModel struct {
	title         string
	inputs        []textinput.Model
	focused       int
	submitted     bool
	cancelled     bool
	values        []string
	dependencies  []FieldDependency // Field dependencies for auto-update
	autoGenerated map[int]bool      // Track which fields have auto-generated values
}

type InputResult struct {
	Values    []string
	Submitted bool
}

func NewInput(title string, prompts []string, defaults []string) InputModel {
	return NewInputWithDependencies(title, prompts, defaults, nil)
}

func NewInputWithDependencies(title string, prompts []string, defaults []string, dependencies []FieldDependency) InputModel {
	inputs := make([]textinput.Model, len(prompts))

	for i, prompt := range prompts {
		input := textinput.New()
		input.Placeholder = prompt
		input.CharLimit = 200
		input.Width = 50 // Set width to display placeholder properly

		if i < len(defaults) && defaults[i] != "" {
			input.SetValue(defaults[i])
		}

		if i == 0 {
			input.Focus()
		}

		inputs[i] = input
	}

	return InputModel{
		title:         title,
		inputs:        inputs,
		values:        make([]string, len(prompts)),
		dependencies:  dependencies,
		autoGenerated: make(map[int]bool),
	}
}

// NewWorktreeInput creates an input dialog for new worktree with auto-path generation
func NewWorktreeInput(title string, worktreePathPrefix string) InputModel {
	prompts := []string{
		"Branch name (e.g., feature/new-feature)",
		"Worktree directory path (e.g., ../feature-branch)",
	}
	defaults := []string{"", ""}

	// Define dependency: branch name (index 0) -> path (index 1)
	dependencies := []FieldDependency{
		{
			SourceIndex: 0,
			TargetIndex: 1,
			UpdateFunc: func(branchName string) string {
				if strings.TrimSpace(branchName) == "" {
					return ""
				}
				// Clean branch name: remove feature/ prefix if present, handle slashes
				cleanBranch := strings.TrimSpace(branchName)
				cleanBranch = strings.ReplaceAll(cleanBranch, "/", "-")
				return filepath.Join(worktreePathPrefix, cleanBranch)
			},
		},
	}

	return NewInputWithDependencies(title, prompts, defaults, dependencies)
}

func (m InputModel) Init() tea.Cmd {
	return textinput.Blink
}

func (m InputModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyCtrlC, tea.KeyEsc:
			m.cancelled = true
			return m, tea.Quit

		case tea.KeyEnter:
			// If on last input or all inputs filled, submit
			if m.focused == len(m.inputs)-1 || m.allInputsFilled() {
				for i, input := range m.inputs {
					m.values[i] = input.Value()
				}
				m.submitted = true
				return m, tea.Quit
			}
			// Otherwise, move to next input
			m.nextInput()

		case tea.KeyTab, tea.KeyShiftTab:
			if msg.Type == tea.KeyTab {
				m.nextInput()
			} else {
				m.prevInput()
			}
		}
	}

	// Update focused input
	var cmd tea.Cmd
	oldValue := m.inputs[m.focused].Value()
	m.inputs[m.focused], cmd = m.inputs[m.focused].Update(msg)
	cmds = append(cmds, cmd)

	// Check if the value changed and update dependent fields
	newValue := m.inputs[m.focused].Value()
	if oldValue != newValue {
		// If user is typing in a target field, mark it as manually edited
		for _, dep := range m.dependencies {
			if dep.TargetIndex == m.focused {
				m.autoGenerated[m.focused] = false
			}
		}

		m.updateDependentFields(m.focused)
	}

	return m, tea.Batch(cmds...)
}

func (m InputModel) View() string {
	if m.submitted || m.cancelled {
		return ""
	}

	var b strings.Builder

	// Title
	b.WriteString(TitleStyle.Render(fmt.Sprintf("📝 %s", m.title)))
	b.WriteString("\n\n")

	// Input fields
	for i, input := range m.inputs {
		// Extract label from placeholder
		placeholder := input.Placeholder
		label := placeholder
		if idx := strings.Index(placeholder, " ("); idx > 0 {
			label = placeholder[:idx]
		}

		// Show label above input
		b.WriteString(NormalStyle.Render(label + ":"))
		b.WriteString("\n")
		b.WriteString(input.View())
		if i < len(m.inputs)-1 {
			b.WriteString("\n\n")
		}
	}

	// Help text
	b.WriteString("\n\n")
	helpText := "tab/shift+tab navigate • enter submit • esc cancel"
	b.WriteString(HelpStyle.Render(helpText))

	return BorderStyle.Render(b.String())
}

func (m InputModel) GetResult() InputResult {
	return InputResult{
		Values:    m.values,
		Submitted: m.submitted,
	}
}

func (m *InputModel) nextInput() {
	m.inputs[m.focused].Blur()
	m.focused = (m.focused + 1) % len(m.inputs)
	m.inputs[m.focused].Focus()
}

func (m *InputModel) prevInput() {
	m.inputs[m.focused].Blur()
	m.focused--
	if m.focused < 0 {
		m.focused = len(m.inputs) - 1
	}
	m.inputs[m.focused].Focus()
}

func (m InputModel) allInputsFilled() bool {
	for _, input := range m.inputs {
		if strings.TrimSpace(input.Value()) == "" {
			return false
		}
	}
	return true
}

// updateDependentFields updates fields that depend on the given source field
func (m *InputModel) updateDependentFields(sourceIndex int) {
	for _, dep := range m.dependencies {
		if dep.SourceIndex == sourceIndex {
			sourceValue := m.inputs[sourceIndex].Value()
			newTargetValue := dep.UpdateFunc(sourceValue)

			// Only update if the target field was auto-generated (not manually edited)
			// or if it's currently empty
			currentTargetValue := m.inputs[dep.TargetIndex].Value()
			if currentTargetValue == "" || m.autoGenerated[dep.TargetIndex] {
				m.inputs[dep.TargetIndex].SetValue(newTargetValue)
				m.autoGenerated[dep.TargetIndex] = true // Mark as auto-generated
			}
		}
	}
}
